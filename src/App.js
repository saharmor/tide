import React, { useState } from "react"
import "./App.css"
import imagesJson from "./images.json"
import Footer from "./Footer"
import SocialShare from "./SocialShare"
import GameActions from "./GameActions"

import Container from 'react-bootstrap/Container'
import Row from 'react-bootstrap/Row'
import Col from 'react-bootstrap/Col'
import Button from 'react-bootstrap/Button'
import Image from 'react-bootstrap/Image'

import { v4 as uuidv4 } from 'uuid';

const Constants = {
  imageSwitchDurationHumanSec: 2,
  imageSwitchDurationAISec: 2,
  imagesPerBatch: 30,
  remoteLmbda: 'https://7tknlfte8j.execute-api.us-west-1.amazonaws.com',
}

const images = imagesJson.sort(() => Math.random() - 0.5)
const sessionId = uuidv4()

const App = () => {
  const [score, setScore] = useState(0);
  const [currImgIdx, setCurrImgIdx] = useState(0);
  const [isTimerActive, setIsTimerActive] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);
  const [isDalle, setIsDalle] = useState(false);
  const [isBatchFinished, setIsBatchFinished] = useState(false);

  function getImageSwitchDuration() {
    if (isBetweenStates()) {
      return 0
    }

    return images[currImgIdx]["is_human"] ? Constants.imageSwitchDurationHumanSec : Constants.imageSwitchDurationAISec
  }

  function isBatchOver() {
    return (currImgIdx + 1) % Constants.imagesPerBatch === 0
  }

  function getNextImageIndex(){
      return currImgIdx + 1
  }

  function changeImage() {
    setIsTimerActive(true)
    setIsBatchFinished(false)
    return new Promise(res => setTimeout(function () {
      setIsDalle(false)
      if (!isBatchOver()) {
        setCurrImgIdx(getNextImageIndex())
      } else {
        setIsBatchFinished(true)
      }
      setIsCorrect(false)
      setIsTimerActive(false)
    }, getImageSwitchDuration() * 1000)
    );
  }

  async function saveDB() {
    const params = {
      "imageId": images[currImgIdx]["id"],
      "runningNum": images[currImgIdx]["running_num"],
      "url": images[currImgIdx]["url"],
      "isHuman": images[currImgIdx]["is_human"],
      "isCorrect": isCorrect,
      "sessionId": sessionId,
    }

    await fetch(Constants.remoteLmbda, { // TODO handle errors
      method: 'POST',
      body: JSON.stringify(params),
    })
  }

  async function handleClick(btnName) {
    if (isTimerActive) {
      return
    }

    if ((images[currImgIdx]["is_human"] && btnName === "human") || (!images[currImgIdx]["is_human"] && btnName === "robot")) {
      // correct
      setScore(previousValue => ++previousValue)
      setIsCorrect(true)
    } else {
      setIsCorrect(false)
    }

    if (images[currImgIdx]["on"] === "DALL-E 2") {
      setIsDalle(true)
    }
    await changeImage()
    await saveDB()
  }

  function getImageByText() {
    if (images[currImgIdx]["is_human"]) {
      return images[currImgIdx]["by"] + " on " + images[currImgIdx]["on"]
    }
    return images[currImgIdx]["by"] + " with " + images[currImgIdx]["on"]
  }

  function getImagePath() {
    if (!isDalle) {
      return "images/" + images[currImgIdx]["running_num"] + ".jpeg"
    }
    return "images/original/" + images[currImgIdx]["running_num"] + ".jpeg"
  }

  function renderPostClick() {
    return (
      <Row className={`pt-2" fs-4 prompt-height`}>
        <span className="text-muted small">By <a href={images[currImgIdx]['url']} target="_blank" rel="noopener noreferrer">{getImageByText()}</a></span>
        {!images[currImgIdx]["is_human"] && <span className="text-muted small">Instruction: {images[currImgIdx]["prompt"]}</span>}
      </Row>
    )
  }

  function playAgain() {
    setCurrImgIdx(getNextImageIndex())
    setIsBatchFinished(false)
    setScore(0)
  }

  function isFinishedAll() {
    return currImgIdx >= images.length || (isBatchFinished && currImgIdx === images.length - 1)
  }

  function isBetweenStates() {
    return isBatchFinished || isFinishedAll()
  }

  function getImagesLeftCount() {
    // check if last batch
    if (images.length - currImgIdx < Constants.imagesPerBatch) {
      return images.length % Constants.imagesPerBatch
    }

    return Constants.imagesPerBatch
  }

  return (
    <Container className="text-center justify-content-center align-items-center" fluid="md">
      <Row className="pt-4">
        <Col className="text-center"><span className="fs-1">This Image Does Not Exist</span></Col>
      </Row>
      <Row className="pt-1 pb-3">
        <Col className="text-center"><span className="fs-6 text-secondary">Can you tell if an image was generated by a human or a machine?</span></Col>
      </Row>

      {isBetweenStates() && <Row className="justify-content-center text-center">
        <Col xs={12}>Done! Your score: <h1 className="text-success">{score}</h1></Col>
        <Col xs={12}>Challenge your friends&nbsp;
          <SocialShare url={"https://thisimagedoesnotexist.com"} title={`Can you tell if an image was generated by a human or a machine? I scored ${score}!`} />
        </Col>
        {!isFinishedAll() && <Col xs={8} className="pt-2">
          <Button className="btn-sm" color="primary" onClick={playAgain}>Play again with new images</Button>
        </Col>}
      </Row>
      }

      {!isBetweenStates() &&
        <Row className="justify-content-center align-items-center pb-2 py-4" xs={12} md={6} lg={6} sm={4}>
          <Col>
            <span className="small">{currImgIdx % Constants.imagesPerBatch + 1}/{getImagesLeftCount()}</span>
          </Col>
        </Row>
      }

      {!isBetweenStates() && <Container>
        <Row className="justify-content-center">
          <Col>
            <Image src={getImagePath(isDalle)} className="img-fluid mx-auto d-block shadow" style={{ height: '18rem', borderRadius: "0.5rem" }} alt="Generated art" />
          </Col>
        </Row>

        <Row className="pt-2 justify-content-center">
          <Col>
            <span className={`${isCorrect ? "text-success fw-bolder fs-3" : "fs-5"}`}>Score: {score}</span>
          </Col>
        </Row>

        <GameActions handleClick={handleClick} isTimerActive={isTimerActive} isCorrect={isCorrect} />
        {isTimerActive && renderPostClick()}
      </Container>
      }

      <Footer />
    </Container>
  );
}

export default App
